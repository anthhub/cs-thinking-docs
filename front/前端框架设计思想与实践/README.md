# 前端框架编程思想与实践  

#### 工作中需要搭建一个高效简洁可扩展的前端框架(模板) ,所以此文探讨软件工程乃至前端框架的一些想法和思考

## 一. 软件系统设计

1. 软件系统特性

    在设计乃至搭建一个框架之前, 我们来思考一下一个好的软件系统应该具备什么特性? 可以需要具备以下特性:

    * 模块化
    * 可复用性
    * 简洁性
    * 可读性
    * ...

    其中哪个最重要? 或者说在编程的时候最应该注重什么? 我认为答案的应该是 '模块化'

    在我的编程经验中, 可复用性,简洁性,可读性等固然重要, 但是过于强调这些, 会给开发工作带来很大负担
    
    曾经有同事在初始框架设计时, 就希望软件可以兼容多个平台, 这样导致了代码侵入了大量业务无关代码, 并且使得目录结构非常怪异, 可读性很差, 而且最后代码复用性斌没有提高.

    正确的做法应该是首要考虑模块化; 当代码模块化做的很好时, 各个部件(组件)之间职责分配明确, 甚至可以达到可拔插, 即模块之间就像积木一样, 添加或是拿掉一个模块, 整个软件任然可以有效的配合和运行. 当系统具有理想的模块化的时候, 可复用性, 简洁性和可读性就自认而然了. 
    
    * 需要代码复用时, 只需要针对各个平台的封装底层完成各自的实现, 而平台具体实现的模块对外界统一暴露一致的接口, 理想化来说, 对于其他模块来说, 是感知不到环境的差别的
    *  简洁性和可读性来说, 业务代码只需要处理具体业务, 软件系统的基本功能通过模块封装好,业务不需要知道具体实现


2. 模块化编程

    众所周知, 软件设计的终极目标就是: '高内聚,低耦合', 模块化(组件化)编程其实也就是 '高内聚,低耦合'的思想

    > 耦合性：也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息
    
    >内聚性：又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。

    >所谓高内聚是指一个软件模块是由相关性很强的代码组成，只负责一项任务，也就是常说的单一责任原则。耦合：一个软件结构内不同模块之间互连程度的度量。
    >对于低耦合，粗浅的理解是：一个完整的系统，模块与模块之间，尽可能的使其独立存在。也就是说，让每个模块，尽可能的独立完成某个特定的子功能。模块与模块之间的接口，尽量的少而简单。如果某两个模块间的关系比较复杂的话，最好首先考虑进一步的模块划分。这样有利于修改和组合。

    简单来说, 或者在实践上总结为一下两点:

    * dependency less, do more -- 用较少少的依赖, 完成最多的功能, 暴露简单的api; 举例来说,前端组件化就是,组件内部封装样式及逻辑暴露属性,外部组件无需知道内部实现,就可以调用
    * change less, enhance more -- 当功能需要变化的时候, 尽量不要侵入新的代码, 而是通过增加新的模块, 增强功能; 例如Hoc, redux/koa中的中间件机制, java中的AOP(面向切片编程)以及js中的装饰器

    上文说道设计模式, 再概略谈一下设计原则SOLID:
    
    * S 单一职责原则
    * O 开发封闭原则
    * L 里式替换原则
    * I 接口独立原则
    * D 依赖导致原则

    设计模式一般来说是指OOP的设计模式, js不是完整面向对象的语言, LID 并不适用于js, 并且(前端)实际使用很少. 而SO是任何语言都适用的设计原则, 其实两者描述的也就是模块化(组件化)编程

    > ps: 补充一下前端代码规范:
    > *  一个文件只能有一个类组件(一般用于处理UI逻辑); 组件不要写的太长, 文件太大影响可读性
    > * 数据和逻辑分离; 可以把组件的可配置部分抽离出来(比如说option)放在一个单独的文件中, 这样既可以减小组件的的大小, 并且后续需求改变只需改动配置, 无需改动组件逻辑

## 二. 前端框架组合设计

1. 组件和状态

    严格来说, react 框架只是一个视图框架 -- [React 用于构建用户界面的 JavaScript 库](https://react.docschina.org/);前端程序与后端程序不同的地方是除了要处理逻辑还要负责布局和样式, 这就使得前端组件嵌套严重, 组件间不是简单的平级关系, 而是多层嵌套形成树状组件, 带来的是组件间复杂的数据交互变得困难, 进而前端出现了状态管理框架
    
     redex(以及衍生)也只是一个状态管理框架, 提供应用级的状态以及改变状态的dispatch方法; 可以思考一下视图层和数据层应该如何结合,才是最有效的呢?

     传统架构如下:

     * 数据层(store): 收集和暴露需要共享的全局状态; 暴露更新状态的dispatch方法(每次dispatch渲染一遍connect的组件)
     * 视图层(components): 处理组件布局; 处理UI逻辑(onChange方法收集数据等); 处理业务逻辑

    实践中我们发现以下问题:
    1. 视图层耦合进了业务逻辑处理具体业务, 导致组件变得臃肿, 复用困难;
    2. 业务逻辑分散到各个组件之中, 业务之间的内聚性不强, 导致业务逻辑复用困难
    3. 由于前端需求经常变化, 而且多端适配性和兼容性常常导致UI逻辑复杂化, 我们发现写纯js(复用逻辑/抽象逻辑)远比写组件(复用组件/抽象组件)要简单
    4. react 组件化初衷是为了前端视图的组件化, 不应该业务逻辑放在组件之中

    以下四点, 再结合react经典公式 view = f(data) -- 即视图只是数据的映射 
    * 组件关心的只是应该如何展示, 不关心数据来源和业务逻辑 
    * 数据层处理结合业务逻辑, 生成组件想要的状态, 驱动视图

    这样一来架构就变成了:

     * 数据层/逻辑层(store/cloud): 收集和暴露需要共享的全局状态; 处理业务逻辑生成状态; 暴露更新状态的dispatch方法(每次dispatch渲染一遍connect的组件)
     * 视图层(components): 处理组件布局; 处理UI逻辑(onChange方法收集数据等)

    这样一来数层的store实际上变成了一个掌控全局业务逻辑的智能云(smart cloud), 也可以说是一个小后台

2. 状态与逻辑

    由于业务逻辑之间是一种强关联的关系, 那么store之间应该如何架构和通信呢?

    现在的数据层已经可以说是一个小后台, 那么我们可以借鉴后台开发经验的OOP封装逻辑, 也引出了OOP编程风格状态管理框架 -- [mobx 简单、可扩展的状态管理](https://cn.mobx.js.org/); 
    
    mobx特性:

    * 简单易用, redux的dispatch/reducer只是store的一个方法; 异步使用async/await
    * OOP的面向对象风格(加上AOP的装饰器); 易于封装和抽象业务; 高内聚,低耦合
    * 易于从多个状态派生出新的状态 
    * 依赖收集, 可以收集实际使用状态的组件, 只渲染变化状态关联的组件; 比redux数据流性能更高
    * 响应式编程; 提供了一系列api, 状态变化也可以驱动方法调用

    mobx store组合最佳实践: [mobx store](https://cn.mobx.js.org/best/store.html)

    ```mermaid
        graph TD
        rootStore[rootStore] --store--> view[视图] 

        view[根组件] --context=state+action--> A[组件A] 
        view[根组件] --context=state+action--> B[组件B] 

        rootStore[rootStore] --> userStore[userStore] 
        userStore[userStore] --> rootStore[rootStore] 

        rootStore[rootStore] --> routerStore[routerStore] 
        routerStore[routerStore] --> rootStore[rootStore] 

        rootStore[rootStore] --> businessStore[businessStore] 
        businessStore[businessStore] --> rootStore[rootStore] 
        
        rootStore[rootStore] --> otherStore[otherStore...] 
        otherStore[otherStore...] --> rootStore[rootStore] 
       
    ```











