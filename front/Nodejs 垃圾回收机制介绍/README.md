# Nodejs 垃圾回收机制介绍

> 过年在家拜读了一下 [深入浅出Node.js], 颇有收获, 分享一下其中内存管理章节.

## 一. 内存管理方案

> 各种编程语言内存管理的方式介绍
    
    现在主流编程内存管理方式如下, 可以看到大部分语言都是采用的 GC 垃圾回收机制.

    - C: 纯手工管理内存
    - C++:  手工管理 + 确定性析构 (RAII)
    - GC 语言(包括 java, go, javascript, python 等):  GC 自动垃圾回收
    - Rust: 借鉴 C++ 的 RAII 的所有权机制

> RAII, 全称资源获取即初始化（英语：Resource Acquisition Is Initialization. RAII要求, 资源的有效期与持有资源的对象的生命期严格绑定, 即由对象的构造函数完成资源的分配（获取）, 同时由析构函数完成资源的释放. 在这种要求下, 只要对象能正确地析构, 就不会出现资源泄露问题. 

    我们知道, 比如C、C++, 语言默认不管理内存, 他们提供 malloc、realloc、calloc 和 free等 , 基本上依赖程序员手动管理, 一方面来说加大了程序员的心智负担 (程序员头顶的达摩克利斯之剑), 而且非常依赖于程序员本身水平, 一方面完全依靠人力, 非常容易出现内存泄漏, 悬垂指针, 引用未初始化内存等问题. 但其好处是运行速度快, 没有运行时开销. C/C++ 功不可没地构建了操作系统内核, 为上层应用搭建基础.

    由于上述原因, 出现了自带 GC 的语言, 现在几乎主流编程语言有 GC 的功能. 其时代背景是 90 年代以来, 全世界对程序的需求越来越大, 此时编程语言的瓶颈不再是运行速度, 而是开发速度, 以至于又出现了解释型编程语言, 程序员不再需要手动内存管理, 极大的降低了编程门槛, 提高的程序员的生产力. 当然这些好处有代价的. GC 增加了运行时开销, 也带来了 "stop the world".

    其中, 年轻的 Rust 语言吸收力借鉴了两种方式的优缺点, 使用所有权机制管理内存, 既不用手动管理, 也无需引入 GC, 以内存安全著称. 这里不做重点, 有兴趣的同学自己了解一下吧.


## 二. 栈和堆
> 深入的了解编程语言内部机制, 总是绕不过栈和堆

 1. 栈(stack)

 顾名思义, 是一种先进后出的结构, 参考一下餐盘的取和放
 ### 栈的特点

    - 由于先进后出性质, 在数据的处理上栈有着很好的速度, 因为只需从最顶部压栈和出栈就好了, 简单明了. 
    -  不过, 存储在栈中的数据必须是大小有限, 生存期确定. 
    -  函数执行的时候会创建一个明确的栈, 并压入, 而当执行期间会存储函数内的所有数据, 这就是栈帧. 个人感觉可以理解为当前执行函数的快照. 
    -  多线程应用程序有多个栈. 
    -  栈的操作系统自动分配或释放. 
    -  存储在栈中的常见类型有：局部变量(值类型、基本类型、常量)、指针和函数
    -  还记得平常偶尔遇到的 stack overflow error 吗？这是因为与堆相比, 栈的大小受到了限制. 大多属语言都是都是这样. 
    
> 函数调用堆栈示例 ![调用堆栈示例](https://user-gold-cdn.xitu.io/2020/2/4/1700e60b3cadfa55?w=1179&h=693&f=gif&s=177834)


 2. 堆(heap)

堆常用来动态内存分配, 程序在堆中寻找数据需要使用指针. 
### 堆的特点

    - 效率不如栈, 但是可以存储更多的数据
    - 可存储大小不确定的数据, 如运行时确定
    - 应用程序中多线程共享堆数据
    - 堆由人工操作, 故管理起来很棘手, 可能会引起内存泄漏等问题, 所以有很多语言有gc机制
    - 存储在堆中的常见类型有：全局变量、引用类型和其他复杂的数据结构
    - 这就是为什么你会遇到 out of memory errors 这类问题, 因为用户的胡乱分配或者未销毁
    - 我们分配给堆的数据其实并没有大小限制, 理论上来说你可以分配无穷大的数据. 当然如果这样你也得为应用程序分配这么多的内存.  -_-


### 内存堆栈 与 数据结构堆栈的区别

 -  | 内存 | 内存 | 
- | :-: | :-: | 
堆	| new一个对象的引用或地址存储在栈区, 指向该对象存储在堆区中的真实数据. 由程序员分配和回收	|是一棵完全二叉树结构 |
栈	| 存储运行方法的形参、局部变量、返回值. 由系统自动分配和回收. |	是一种连续存储的数据结构, 特点是存储的数据先进后出|


**由于栈是由系统分配和回收, 所以我们接下来讨论的自动内存管理主要是堆.**

## 三. Node 与 V8

>  Node 是一个构建在 Chrome V8上 的 JavaScript 运行时上的平台.

2009年, Node的创始人Ryan Dahl选择了V8来作为 Node 的 JavaScript脚本引擎, 这离不开当时硝烟四起的第三次浏览器大战. 那次大战中, 来自 Google 的 Chrome 浏览器以其优异的性能成为焦点. Chrome 成功的背后离不开 JavaScript 引擎 V8. 

V8 出现后, JavaScript 一改它作为脚本语言性能低下的形象. 在接下来的性能跑分中, V8 持续领跑至今. V8 的性能优势使得用 JavaScript 写高性能后台服务程序成为可能. 在这样的契机下, Ryan Dahl 选择了 JavaScript, 选择了 V8, 在事件驱动、非阻塞I/O模型的设计下实现了 Node. 

关于V8, 它的来历与背景亦是大有来头. 作为虚拟机, V8的性能表现优异, 这与它的领导者有莫大的渊源, Chrome 的成功也离不开它背后的天才----Lars Bako在Lars的工作履历里, 绝大部分都是与虚拟机相关的工作. 在开发V8之前, 他曾经在Sun公司工作, 担任 HotSpot 团队的技术领导, 主要致力于开发高性能的Java虚拟机. 在这之前, 他也曾为 Self、Smalltalk 语言开发过高性能虚拟机. 这些无与伦比的经历让 V8 一出世就超越了当时所有的 JavaScript 虚拟机. 

### V8 架构

> V8 架构 ![v8](https://pic3.zhimg.com/80/v2-2f0b94fa2ce2a89122b7a17be114a826_720w.jpg)

    - 新生代空间：是最新产生的数据存活的地方, 这些数据往往都是短暂的. 这个空间被一分为二, 然后被Scavenger(Minor GC)所管理. 稍后会介绍. 可以通过V8标志如 -- max_semi_space_size 或 --min_semi_space_size 来控制新生代空间大小
    - 老生代空间：是从新生代空间经过至少两轮Minor GC仍然存活下来的数据, 该空间被Major GC(Mark-Sweep & Mark-Compact)管理, 稍后会介绍. 可以通过 --initial_old_space_size 或 --max_old_space_size 控制空间大小. 
    -  Old pointer space： 存活下来的包含指向其他对象指针的对象
    -  Old data space： 存活下来的只包含数据的对象. 
    -  大对象空间： 这是比空间大小还要大的对象, 大对象不会被gc处理. 
    -  代码空间：这里是JIT所编译的代码. 这是除了在大对象空间中分配代码并执行之外的唯一可执行的空间. 
    -  map空间：存放 Cell 和 Map, 每个区域都是存放相同大小的元素, 结构简单. 


Node 在 JavaScript 的执行上直接受益于 V8, 可以随着V8的升级就能享受到更好的性能或新的语言特性（如ES5和ES6）等. 

**同时也受到 V8 的一些限制, 尤其是本章要重点讨论的内存限制**.

### 内存限制

在一般的后端开发语言中, 在基本的内存使用上没有什么限制, 然而在Node中通过JavaScript使用内存时 
就会发现只能使用部分内存（64位系统下约为1.4 GB, 32位系统下约为0.7 GB）. 在这样的限制下, 将会 
导致Node无法直接操作大内存对象, 比如无法将一个2 GB的文件读入内存中进行字符串分析处理, 即使物 
理内存有32 GBo这样在单个Node进程的情况下, 计算机的内存资源无法得到充足的使用. 

造成这个问题的主要原因在于Node基于V8构建, 所以在Node中使用的JavaScript对象基本上都是通过V8自 
己的方式来进行分配和管理的. V8的这套内存管理机制在浏览器的应用场景下使用起来绰绰有余, 足以胜 
任前端页面中的所有需求. 但在Node中, 这却限制了开发者随心所欲使用大内存的想法. 

> 查看 Node 内存使用量
``` js 
$ node
> process.memoryUsage();
{
  rss: 22986752,
  heapTotal: 4907008,
  heapUsed: 2632872,
  external: 1512434,
  arrayBuffers: 9415
}
```

> 其中 heapTotal 和 heapUsed 是 V8 的堆内存使用情况, 前者是已申请到的堆内存, 后者是当前使用的量.

## 四. V8的垃圾回收
> 

``` js 
class Employee {
    constructor(name, salary, sales) {
        this.name = name;
        this.salary = salary;
        this.sales = sales;
    }
}

const BONUS_PERCENTAGE = 10;

function getBonusPercentage(salary) {
    const percentage = (salary * BONUS_PERCENTAGE) / 100;
    return percentage;
}

function findEmployeeBonus(salary, noOfSales) {
    const bonusPercentage = getBonusPercentage(salary);
    const bonus = bonusPercentage * noOfSales;
    return bonus;
}

let john = new Employee("John", 5000, 5);
john.bonus = findEmployeeBonus(john.salary, john.sales);
console.log(john.bonus);
```

[代码示例](https://speakerdeck.com/deepu105/v8-memory-usage-stack-and-heap)

> 全局向下文像一个快照一样保存在栈上, 每一次函数调用也会将一个快照放到栈中, 包括函数的局部变量, 参数和返回值. 基本类型保存在栈中, 对象、复杂类型或者引用类型保存在堆中. 任何函数的调用都会在栈顶被压入. 一旦主进程完成所有任务, 堆中的对象便不会被引用而孤立.

### 新生代管理 Minor GC (Scavenger)

清道夫GC, 主要管理新生代空间, 保证新生代空间的紧凑和干净.所有的对象都会分配到新生代空间, 新生代空间相对较小.大约在1M ~ 8M, 可以通过命令控制.

该GC流程大致是这样： 新生代空间由两个等分的空间组成, to-space和from-space, 可以把这两个名字理解为阶段(当前使用 和 当前未使用), 而不是名字.当当前使用没有更多内存后, 触发Minor GC. 比如, 当当前使用没有更多空间了, 这时候, 新增了一个待分配空间对象, Minor GC会吧当前未使用切换为当前使用, 然后将之前已满负荷的空间中的数据, 根据是否存活整理到新的、空的当前使用中.存活的就放过去, 非存活的就扔掉.并且在移动存活数据的时候, 会紧凑摆放, 避免空间浪费.最后吧待分配空间对象, 分配到新的当前使用中. 当更多的待分配空间进来时, 会重复上面流程, 但是如果一个数据存活两次以上, 它就会被扔到老生代空间.以保证新生代空间的新.

[示例](https://speakerdeck.com/deepu105/v8-minor-gc)

### 老生代管理 -- Major GC(Mark-Sweep & Mark-Compact)

对于老生代中的对象, 由于存活对象占较大比重, 再采用Scavenge的方式会有两个问题：一个是存活对象较多, 复制存活对象的效率将会很低；另一个问题依然是浪费一半空间的问题. 这两个问题导致应对生命周期较长的对象时Scavenge会显得捉襟见肘. 为此, V8在老生代中主要采用了Mark - Sweep 和 Mark - Compact相结合的方式进行垃圾回收. 

1. Mark-Sweep

Mark-Sweep是标记清除的意思, 它分为标记和清除两个阶段. 与Scavenge相比, Mark-Sweep并不将内存空间划分为两半, 所以不存在浪费一半空间的行为. 与Scavenge复制活着的对象不同, Mark-Sweep在标记阶段遍历堆中的所有对象, 并标记活着的对象, 在随后的清除阶段中, 只清除没有被标记的对象. 可以看出, Scavenge中只复制活着的对象, 而Mark-Sweep只清理死亡对象. 活对象在新生代中只占较小部分, 死对象在老生代中只占较小部分, 这是两种回收方式能高效处理的原因. 

> Mark-Sweep最大的问题是在进行一次标记清除回收后, 内存空间会出现不连续的状态. 这种内存碎片会对后续的内存分配造成问题, 因为很可能出现需要分配一个大对象的情况, 这时所有的碎片空间都无法完成此次分配, 就会提前触发垃圾回收, 而这次回收是不必要的. 

为了解决Mark-Sweep的内存碎片问题, Mark-Compact被提出来. 


2. Mark-Compact是标记整理的意

Mark-Compact是标记整理的意思, 是在Mark-Sweep的基础上演变而来的. 它们的差别在于对象在标记为死亡后, 在整理的过程中, 将活着的对象往一端移动, 移动完成后, 直接清理掉边界外的内存. 图5-7为Mark-Compact完成标记并移动存活对象后的示意图, 白色格子为存活对象, 深色格子为死亡对象, 浅色格子为存活对象移动后留下的空洞. 

3. Incremental Marking

为了避免出现JavaScript应用逻辑与垃圾回收器看到的不一致的情况, 垃圾回收的3种基本算法都需要将应用逻辑暂停下来, 待执行完垃圾回收后再恢复执行应用逻辑, 这种行为被称为“全停顿”（stop-the-world）. 在V8的分代式垃圾回收中, 一次小垃圾回收只收集新生代, 由于新生代默认配置得较小, 且其中存活对象通常较少, 所以即它是全停顿的影响也不大. 但V8的老生代通常配置得较大, 且存活对象较多, 全堆垃圾回收（full垃圾回收）的标记、清理、整理动作造成的停顿就会比较可怕, 需要设法善. 

为了降低全堆垃圾回收带来的停顿时间, V8先从标记阶段入手, 将原本要一口气停顿完成的动作改为增量标记（incremental marking）,也就是拆分为许多小“步进”, 每做完一 “步进”就让JavaScript应用逻辑执行一小会儿, 垃圾回收与应用逻辑交替执行直到标记阶段完成. 


## 五. 堆外内存

Node的内存构成主要由通过V8进行分配的部分和Node自行分配的部分. 受V8的垃圾回收限制的主要是V8的堆内存.

Buffer 对象是由 Node 自行分配的

> 参考
 ![深入浅出Node.js](https://img9.doubanio.com/view/subject/l/public/s27134708.jpg)
