# Nodejs 垃圾回收机制介绍

> 过年在家拜读了一下 [深入浅出Node.js], 颇有收获, 分享一下其中内存管理章节.

## 一. 内存管理方案
1. 各种编程语言内存管理的方式介绍
    
    现在主流编程内存管理方式如下, 可以看到大部分语言都是采用的 GC 垃圾回收机制.

    - C: 纯手工管理内存
    - C++:  手工管理 + 确定性析构 (RAII)
    - GC 语言(包括 java, go, javascript, python 等):  GC 自动垃圾回收
    - Rust: 借鉴 C++ 的 RAII 的所有权机制

> RAII，全称资源获取即初始化（英语：Resource Acquisition Is Initialization. RAII要求，资源的有效期与持有资源的对象的生命期严格绑定，即由对象的构造函数完成资源的分配（获取），同时由析构函数完成资源的释放。在这种要求下，只要对象能正确地析构，就不会出现资源泄露问题。

    我们知道, 比如C、C++, 语言默认不管理内存, 他们提供 malloc、realloc、calloc 和 free等 , 基本上依赖程序员手动管理, 一方面来说加大了程序员的心智负担 (程序员头顶的达摩克利斯之剑), 而且非常依赖于程序员本身水平, 一方面完全依靠人力, 非常容易出现内存泄漏, 悬垂指针, 引用未初始化内存等问题. 但其好处是运行速度快, 没有运行时开销. C/C++ 功不可没地构建了操作系统内核, 为上层应用搭建基础.

    由于上述原因, 出现了自带 GC 的语言, 现在几乎主流编程语言有 GC 的功能. 其时代背景是 90 年代以来, 全世界对程序的需求越来越大, 此时编程语言的瓶颈不再是运行速度, 而是开发速度, 以至于又出现了解释型编程语言, 程序员不再需要手动内存管理, 极大的降低了编程门槛, 提高的程序员的生产力. 当然这些好处有代价的. GC 增加了运行时开销, 也带来了 "stop the world".

    其中, 年轻的 Rust 语言吸收力借鉴了两种方式的优缺点, 使用所有权机制管理内存, 既不用手动管理, 也无需引入 GC, 以内存安全著称. 这里不做重点, 有兴趣的同学自己了解一下吧.




    

> 参考
 ![深入浅出Node.js](https://img9.doubanio.com/view/subject/l/public/s27134708.jpg)
